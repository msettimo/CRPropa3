/*=====================================================================	License	=======		    This file is part of xHERMES () and EleCa packages for     multi messenger data analysis.	(C) Copyright 2009, 2010, 2011  Manlio De Domenico		Author: Manlio De Domenico	Lab. for Complex Systems, Scuola Superiore di Catania	Universita' degli Studi di Catania, Italy	Mail: manlio.dedomenico@ct.infn.it	(C) Copyright 2011, 2012 Mariangela Settimo		Author: Mariangela Settimo	Universaat Siegen, Germany	Mail: settimo@hep.physik.uni-siegen.de	=====================================================================*/// System Headers#include <stdlib.h>#include <stdio.h>#include <fstream>#include <cstring>#include <cmath>#include <iostream>#include <iomanip>#include <math.h>#include <errno.h>using namespace std;#include <sstream>//#include <TFile.h>//#include <TTree.h>//read input filesifstream inputfile;ofstream outfile;ifstream fin;double E0taborg; double theta0tab;//propagationvector< vector<double> > ParticleMatrix;vector< vector<double> > ParticleAtGround;double RKstepsize; double globz0;double globE0;int offsetid;double eps0tab; double epstab;double Eoutput;double EoutputG;double EoutputBT;double EoutputLoss;double Einput;double EinputEps;double wnucl[3];int Anucl;int Znucl;int Anuclf;int Znuclf;double z0nucl;double E0nucl;double z0nuclf;double E0nuclf;unsigned int Ntotph;double zph; double Eph;//double zph[10000];//double Eph[10000];double Ethr;double Bfield;double E0ph;double z0ph;int NsecBT;int NsecG; int pnum;double EBelowThr[200000];double zBelowThr[200000];int typeBelowThr[200000];double EGround[200000];double zGround[200000];int typeGround[200000];string BACKGROUNDRAD;//init integralsdouble integral_nepsALL;double integral_nepsCMB;double integral_nepsCIB;double integral_nepsCIOB;double integral_nepsURB;int POINTS_VERY_FEW =100;static const int MC_SAMPLING = 1000;    // It could be expensive to create and destroy arrays within routines,// the idea is to perform this action once, at the beginning.double (*MC_Sampling_Hist)[3] = new double [MC_SAMPLING][3];// NOTE: it is possible to improve the performance by removing one component// from the above array (component [1]), but improvement will not be dramatic.//vector<double>BackgroundArray;// Random generators Libs#ifndef __RANDOM__#define __RANDOM__    #include "RandomLib/rvgs.c"    #include "RandomLib/rngs.c"#endif /*__RANDOM__*/const char *VERSION = "0.1";/* Precision in I/O tasks *///int PRECISION = 10;static const double rel_error= 1E-12;static const bool TRUE = 1;static const bool FALSE = 0;#define MODULUS    2147483647 /* DON'T CHANGE THIS VALUE                  */int SEED = 123456789;//#####################//# Runge-Kutta//#####################// Needed for the optimized version of the propagation codestatic const int RK_ORDER = 6;double (*vRKa) = new double [RK_ORDER+1];double (*vRKc) = new double [RK_ORDER+1];double (*vRKcs) = new double [RK_ORDER+1];double (*vRKb)[RK_ORDER+1] = new double [RK_ORDER][RK_ORDER+1];        //##################################################################// constants for magnetic fields//##################################################################/* Model Parameters */static const int D = 6;     // phase space dimension of the system                            // x from 0 to 2                            // v from 3 to 5static const double Earth_l_G = 180.;           // degstatic const double Galaxy_X_Bound = 20e3;       // pcstatic const double Galaxy_Y_Bound = 20e3;       // pcstatic const double Galaxy_Z_Bound = 50e3;       // pcstatic const double Galaxy_Out_Bound = 20e3;     // pc [see arXiv:astro-ph/0510444v2]static const double gZCharge_Default = 1.;      // estatic const double gEnergy_Default = 1e18;     // eVstatic const double gMass_Default = 1;          // proton static const double gRedshift_Default = 0.1;      // redshiftstring gSourcePosition_Default = "0,0";      // source positionstatic const double gCohLengthMin_Default = 1e3;   // pcstatic const double gCohLengthMax_Default = 3e6;   // pcstatic const double gB0_Default = 1e-9;            // Gstatic const double gBIrrRms_Default = 0.1e-9;     // Gstatic const int gBIrrModes_Default = 100;static const int gBModel_Default = 1;    static const int gIterations_Default = 100000;static const double gGamma_Default = (double)11./3.;static const int MAX_MODES = 1000;        // Maximum number of modes allowedstatic const int MAX_LEN = 1000000;       // Maximum trajectory length alloweddouble TIME_STEP = 1;                     // Time step for trajectory estimationdouble SEEDmag = -1;/* Precision parameters */static const double EPS = 1e-09;static const double PRECISION = 12;//##########################################################################//# Constants//##########################################################################/* Mathematical constants */static const double cPI = 4*atan(1);static const double cPIsq = cPI*cPI;static const double RAD2DEG = (double)180./cPI;//static const double DEG2RAD = (double)1./RAD2DEG;/* Cosmological constants */static const double eV2J = 1.602176487e-19; // from eV to J/* Monte Carlo constants */static const double MC_TOLER = 1e-4;static const long MC_MAX_STEPS = 1000000;static const double M2MPC = 3.240779e-17/1e6;static const double KM2MPC =  3.240779e-20;static const double S2YR = 3.168808781403e-08;double H0 = 70.4;                                   // [km/s/Mpc], Hubble constantdouble H0y = H0*(double)KM2MPC/S2YR;   // H0 per yearsdouble OC = 0.227;  // Dark matter densitydouble OB = 0.0456; // Baryon densitydouble OM = OB+OC;  // Matter densitydouble OL = 0.728;  // Dark energy densitystatic const double K_CBR = 1.318684673251832e+13; // =1/pi**2/hbarc**3 [eV^-3 cm^-3]static const double CIB_endens = 0.004;                     // [eV cm^-3]static const double COB_endens = 0.001;                     // [eV cm^-3]static const double CIOB_endens = COB_endens+CIB_endens;    // [eV cm^-3]static const double CMB_endens = 0.260;                     // [eV cm^-3]double tmp_factor = 0;double norm_factor = 0;/* Particle parameters */static const double AlphaFineStruct = (double)1./137.35999084;  // Fine structure constantstatic const double ElectronCharge = 1.60217646e-19; // [C]static const double ElectronMass = 0.510998918e6; // [eV/c^2]static const double ProtonMass = 0.938272029e9;   // [eV/c^2]static const double NeutronMass = 0.939565378e9;  // [eV/c^2]static const double PionMass = 0.13957018e9;      // [eV/c^2]static const double Pi0Mass = 0.13497666e9;       // [eV/c^2]static const double PiMass = 0.13957018e9;        // [eV/c^2] Pi+ or -static const double MuMass = 0.105658367e9;       // [eV/c^2]static const double NeutronLifeTime = 885.7;      // [s]static const double PiLifeTime = 2.6e-8;          // [s]static const double Pi0LifeTime = 8.4e-17;        // [s]static const double MuLifeTime = 2.2e-6;          // [s]//static const double Hbar = 6.58211899e-16;        // [eV s] static const double C_speed = 299792458;          // [m/s] speed of lightstatic const double K_boltz = 8.617342294984e-5;  // [eV/K ] Boltzman constantstatic const double M2KPC = 3.24077649e-20;static const double S2KYR = 3.168808781403e-11;static const double c_speed_kpc_kyr = C_speed*(double)M2KPC/S2KYR;static const double c_speed_kpc_kyr_sq = c_speed_kpc_kyr*c_speed_kpc_kyr;static const double c_speed_Mpc_Myr = c_speed_kpc_kyr;static const double c_speed_Mpc_Myr_sq = c_speed_kpc_kyr_sq;static const double c_speed_pc_yr = c_speed_kpc_kyr;static const double c_speed_pc_yr_sq = c_speed_kpc_kyr_sq;// new constants static const double ElectronRadius = 2.8179e-13; // [cm]static const double h_Planck = 4.135667e-15; // [eV s]// 6.626006957e-34; //[Js]static const double hcut_Planck = h_Planck/2/cPI; // [eV s] hcut = h/2Pi [Js]static const double Hbar = hcut_Planck;        // [eV s] static const double WienB = 2.89776e-3; // m·Kstatic const double SigmaThompson = 6.6524e-25; //8/3*cPI*pow(ElectronRadius,2); //cm^-2 static const double T_CMB = 2.725; // [K] // evolution 2.725*(1-z)  1012.3164 static const double T_COB = 5270; // [K]  // Visible [380 - 760] nm. Scelgo 550  // for the IR, OP and CRB I derive the temperature from the Wien law: T = WienB/lambda. static const double T_CIB = 1.45e+02; // [k] Middle IR 5 to (25-40) µm according to Nasa. scelgo 20e-6 mstatic const double T_CRB = 3e-03; // [k] ~ cm - 10m.  scelgo ~1 mstatic const double CMB_en = K_boltz*T_CMB; //2.348e-4;             // [eV]static const double CRB_en = K_boltz*T_CRB; static const double COB_en = K_boltz*T_COB; static const double CIB_en = K_boltz*T_CIB; static const double CIOB_en = CIB_en+COB_en;    // [eV]// constants for ICSstatic const double LambdaCompton = hcut_Planck/(ElectronMass/C_speed); // hcut/mc = compton wavelengh of the electron.static const double C_E = 0.5772; // euler's constantstatic const double C_L = 0.5700; // ??? see Blumenthal, Gould, 1970/* Photopion production for protons */static const double A_pi = 3.66e-8; // [1/yr]static const double B_pi = 2.87e20; // [eV]static const double C_pi = 2.42e-8; // [1/yr]/* Pair production for all nuclei */static const double A_pair_CMB = (double)( pow(AlphaFineStruct,3.)*pow(ElectronMass*ProtonMass,2.) )/(4*cPIsq)/Hbar/S2YR;static const double B_pair_CMB = ElectronMass*ProtonMass*(double)1./(2*K_boltz*T_CMB);static const double B_pair_COB = ElectronMass*ProtonMass*(double)1./(2*K_boltz*T_COB);static const double Beta_CIB = 0.4;static const double eps0_CIB = 3.e-2;   // [eV]static const double n0_CIB = 1.e-3;   // [eV/cm^3]static const double C_pair[5] = { 0.,0.8048,0.1459,1.1373e-3,-3.879e-6 };static const double D_pair[5] = { -86.07,50.96,-14.45,2.666666666666667,0. };static const double F_pair[5] = { 0.,2.910,78.35,1837.,0. };/* Maximum photon energy (rest frame) */static const double eps_ph_inf_urb = 4.1e-12;   // [eV]static const double eps_ph_inf_cmb = 0.825e-6;   // [eV]static const double eps_ph_inf_cib = 2e-3;   // [eV]static const double eps_ph_inf_cob = 5e-2;   // [eV]static const double eps_ph_inf_ciob = 2e-3;   // [eV]static const double eps_ph_sup_urb = eps_ph_inf_cmb;//4e-5;   // [eV]static const double eps_ph_sup_cmb = eps_ph_inf_cob;   // [eV]static const double eps_ph_sup_cob = 9.9;   // [eV]static const double eps_ph_sup_cib = 0.8;   // [eV]static const double eps_ph_sup_ciob = 9.9;   // [eV]static const double eps_ph_sup_global = eps_ph_sup_cob;   // [eV] *globalstatic const double eps_ph_inf_global = eps_ph_inf_urb;   // [eV] *global/* Photopion/Photodisintegration production for nuclei */static const double eps_1 = 30.e6;      // [eV]static const double eps_max = 150.e6;   // [eV]//static const double A_BP = (cPI*8./3.) * AlphaFineStruct * pow(Hbar*C_speed,2.) * (double)1./ProtonMass;   // [mb MeV]static const double A_pi_conv = 0.5/C_speed;double E_THRES_FOLLOW = 1.e18; // [eV] discard particles with smaller Edouble EPSTHR1N = 0;double EPSTHR2N = 0;double EPS01N = 0;double XI1N = 0;double DELTA1N = 0;double EPS02N = 0;double XI2N = 0;double DELTA2N = 0;double ZETA = 0;double BrRatio[50] = { 0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0. };//other vars for ROOT and ELECA classint particle_type = 0;double EnergyCM =0;double GammaEnergy = 0;double BackGamma = 0;double PPxsection = 0;double DPPxsection = 0;double TPPxsection = 0;double ICSxsection = 0;double PPlength = 0;double DPPlength = 0;double TPPlength = 0;double ICSlength = 0;double n_eps2 = 0;double eps2 = 0;double feps_inf =  eps_ph_inf_global;double feps_sup =  eps_ph_sup_global;double Ecmtab;double PPeps;double DPPeps;double ICSeps;double TPPeps;//int ntheta;double Etab;//double Esofttab;double dEtab;double depstab;//double thetatab[360];double PPle[360];double DPPle[360];double TPPle[360];double ICSle[360];vector<double> vEtab;vector<double> vPPle;vector<double> vDPPle;vector<double> vTPPle;vector<double> vICSle;double PPsigma;double DPPsigma;double TPPsigma;double ICSsigma;bool debug;//##########################################################################//# Functions//##########################################################################double z2Mpc(double z){    if( z<0.4 ){        return ((double)C_speed/1000./H0)*z;    }else{        // AV Uryson, Physics Particles and Nuclei, 2006, Vol. 37, No. 3, pp. 347   67        // Assuming flat-matter-dominated cosmology. Error is negligible        return ((double)C_speed/1000./H0)*(2./3.)*(1-pow(1.+z,-1.5));    }}    double Mpc2z(double D){    if( D<1700. ){        return (double)D/((double)C_speed/1000./H0);    }else{        // AV Uryson, Physics Particles and Nuclei, 2006, Vol. 37, No. 3, pp. 347   67        // Assuming flat-matter-dominated cosmology. Error is negligible        return pow(1-(double)D/((2./3.)*(double)C_speed/1000./H0),-2./3.)-1;    }}